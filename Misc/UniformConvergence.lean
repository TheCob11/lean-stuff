import Mathlib
open Topology Uniformity

example [TopologicalSpace X] [PseudoMetricSpace Y] {F: Œπ ‚Üí X ‚Üí Y}
  (hF: ‚àÄi, Continuous (F i)) (tendsto_F : TendstoUniformly F f l) [l.NeBot] : Continuous f :=
  continuous_iff_continuousAt.mpr fun x ‚Ü¶ Metric.tendsto_nhds.mpr fun Œµ Œµ_pos ‚Ü¶
  let Œµ3 := Œµ/3
  have Œµ3_pos: Œµ3 > 0 := div_pos Œµ_pos three_pos
  let ‚ü®i, hi‚ü© := Metric.tendstoUniformly_iff.mp tendsto_F Œµ3 Œµ3_pos |>.exists
  have := Metric.continuous_iff'.mp (hF i) x Œµ3 Œµ3_pos
  this.mono fun y h ‚Ü¶ calc
    _ ‚â§ dist (f y) (F i y) + dist (F i y) (F i x) + dist (F i x) (f x) := dist_triangle4 ..
    _ < Œµ3 + Œµ3 + Œµ3 := add_lt_add
      (add_lt_add (hi y) h)
      (dist_comm .. |>.trans_lt <| hi x)
    _ = Œµ := add_thirds Œµ

example [TopologicalSpace X] [UniformSpace Y] {F: Œπ ‚Üí X ‚Üí Y}
  (hF: ‚àÄ·∂†i in l, Continuous (F i)) (tendsto_F : TendstoUniformly F f l) [l.NeBot] : Continuous f :=
  continuous_iff_continuousAt.mpr fun x ‚Ü¶ Uniform.continuousAt_iff'_right.mpr fun _s hs ‚Ü¶
  let ‚ü®v, v_mem, v_symm, hv3s‚ü© := comp_comp_symm_mem_uniformity_sets hs
  let ‚ü®_I‚ÇÅ, hI‚ÇÅl, hI‚ÇÅ‚ü©: ‚àÉI ‚àà l, ‚àÄi ‚àà I, ‚àÄy, (f y, F i y) ‚àà v := tendsto_F v v_mem |>.exists_mem
  let ‚ü®_I‚ÇÇ, hI‚ÇÇl, hI‚ÇÇ‚ü©: ‚àÉI ‚àà l, ‚àÄi ‚àà I, ‚àÄ·∂†y in ùìù x, (F i x, F i y) ‚àà v :=
    hF.mono (fun _ h ‚Ü¶ Uniform.continuous_iff'_right.mp h x v_mem) |>.exists_mem
  let ‚ü®i, hi‚ÇÅ, hi‚ÇÇ‚ü© := l.nonempty_of_mem <| l.inter_mem hI‚ÇÅl hI‚ÇÇl
  have : ‚àÄ·∂†y in ùìù x, (f x, f y) ‚àà v ‚óã v ‚óã v := Filter.Eventually.mono (hI‚ÇÇ i hi‚ÇÇ)
    fun y hy ‚Ü¶ ‚ü®F i y, ‚ü®F i x, hI‚ÇÅ i hi‚ÇÅ x, hy‚ü©, v_symm.mk_mem_comm.mp <| hI‚ÇÅ i hi‚ÇÅ y‚ü©
  this.mono fun _ h ‚Ü¶ hv3s h

-- annotated version :)
/- note about `Filter.Eventually`:
For `p: Œπ ‚Üí Prop` and `l: Filter Œπ`, `‚àÄ·∂†i in l, p i` means that `p` is _eventually_ true along `l`,
i.e. for sufficiently "large" i (with respect to l). The direct translation is `{i | p i} ‚àà l`,
or equivalently `‚àÉv ‚àà l, ‚àÄi ‚àà v, p i`.
Ex: for `l: Filter ‚Ñï := Filter.atTop` (the filter generated by intervals [0, n] representing
a limit ‚Üí ‚àû), `‚àÄ·∂†i in l, p i` means `‚àÉN, ‚àÄn ‚â• N, p n`.
Ex: `Filter.Tendsto f (ùìù x) (ùìù y)` (f approaches y at x) ‚Üî `‚àÄV ‚àà ùìù y, ‚àÄ·∂†a in ùìù x, f a ‚àà V`,
i.e. `‚àÄV ‚àà ùìù y, ‚àÉU ‚àà ùìù x, ‚àÄa ‚àà U, f a ‚àà V`
Also, `Filter.Eventually.mono` maps eventualities across implications:
`(‚àÄ·∂†x in l, p x) ‚Üí (‚àÄx, p x ‚Üí q x) ‚Üí ‚àÄ·∂†x in l, q x`
-/

example
  {X Y Œπ: Type*} -- spaces X and Y, indexing type Œπ
  [TopologicalSpace X] [UniformSpace Y]
  {F: Œπ ‚Üí X ‚Üí Y} -- our "sequence" of functions is an arbitrary Œπ-indexed family
  {f: X ‚Üí Y}
  {l: Filter Œπ} -- l is the Œπ-"sequence" along which F_i approaches f, like .atTop for ‚Üí‚àû
  (tendsto_F : TendstoUniformly F f l)
  (hF: ‚àÄ·∂†i in l, Continuous (F i)) -- F_i is eventually continuous (a ‚àÄi would be so impatient)
  [l.NeBot] -- sets in l are nonempty (if ‚àÖ ‚àà l, then l would contain all sets)
  : Continuous f :=
  /-
  Continuity in uniform spaces is equivalent to `‚àÄa: X, Filter.Tendsto (f a, f ¬∑) (ùìù a) (ùì§ Y)`,
  so `‚àÄs ‚àà ùí∞ Y, (f a, f ¬∑) ‚Åª¬π' s ‚àà ùìù a` ‚Üî `‚àÄs ‚àà ùí∞ Y, ‚àÄ·∂†b in ùìù a, (f a, f b) ‚àà s`.
  `ùí∞ Y: Filter (Y √ó Y)` is the filter of entourages in Y, the defining structure of a uniform space,
  which are kind of like (generated by, for metric spaces) `{(a, b) | dist a b < Œµ}`).
  This is a lot like saying "f a is eventually s-close to f y for any closeness s"
  -/
  Uniform.continuous_iff'_right.mpr fun a _s hs ‚Ü¶
  /-
  this is like a triple triangle inequality for uniform spaces, where from our entourage `s ‚àà ùí∞ Y`
  we can get a smaller entourage `v ‚àà ùí∞ Y`, such that `v ‚óã v ‚óã v ‚äÜ s` (where `‚óã` is composition of
  relations `A ‚óã B = {(a, b) | ‚àÉc, (a, c) ‚àà A ‚àß (c, b) ‚àà B}`), with the added property that
  `v` is symmetric `(a, b) ‚àà v ‚Üî (b, a) ‚àà v`. This is a lot like getting an Œµ/3-ball from an Œµ-ball.
  -/
  let ‚ü®(v: Set (Y √ó Y)), (v_mem: v ‚àà ùì§ Y), (v_symm: IsSymmetricRel v), (hv3s: v ‚óã v ‚óã v ‚äÜ _s)‚ü© :=
    comp_comp_symm_mem_uniformity_sets hs
  -- now, we get two useful sets of Œπs in l (kind of like thresholds in a sequence)
  /- first, since F uniformly tends to f along l, we can get an `I‚ÇÅ ‚àà l` such that for all the
  `i ‚àà I‚ÇÅ` ("after" the threshold set by I), every `b: X` satisfies `(f b, F i b)` ‚àà v, i.e.
  `f b` is "v-close" ("Œµ/3-close") to `F i b`.
  -/
  let ‚ü®_I‚ÇÅ, hI‚ÇÅl, hI‚ÇÅ‚ü©: ‚àÉI ‚àà l, ‚àÄi ‚àà I, ‚àÄb, (f b, F i b) ‚àà v := tendsto_F v v_mem |>.exists_mem
  /- the next set of Œπs we get is from the fact that F is eventually continuous, using the same
  uniform space formulation of continuity as before, so for all the `i ‚àà I‚ÇÇ`,
  `F i a` is eventually v-close to `F i b` along `ùìù a`, i.e. `‚àÉU ‚àà ùìù a, ‚àÄb ‚àà U, ...`.
  -/
  let ‚ü®_I‚ÇÇ, hI‚ÇÇl, hI‚ÇÇ‚ü©: ‚àÉI ‚àà l, ‚àÄi ‚àà I, ‚àÄ·∂†b in ùìù a, (F i a, F i b) ‚àà v :=
    hF.mono (fun _ h ‚Ü¶ Uniform.continuous_iff'_right.mp h a v_mem) |>.exists_mem
  /- now that we have these two useful regions of Œπ, we take the `i: Œπ` that we'll actually use
  from the intersection `I‚ÇÅ ‚à© I‚ÇÇ`, which is guaranteed to exist because
  `I‚ÇÅ ‚à© I‚ÇÇ ‚àà l` (by filter axioms) and `‚àÄI ‚àà l, I.Nonempty` because of our `l.NeBot` assumption.
  -/
  let ‚ü®i, hi‚ÇÅ, hi‚ÇÇ‚ü© := l.nonempty_of_mem <| l.inter_mem hI‚ÇÅl hI‚ÇÇl
  -- first, we use the I‚ÇÇ property to get `F i a` eventually v-close to `F i b` along `ùìù a`
  have : ‚àÄ·∂†b in ùìù a, (F i a, F i b) ‚àà v := hI‚ÇÇ i hi‚ÇÇ
  /- now, we actually use that triangle-inequality-esque property of v (well, the triangle part) to
  get `f a` eventually v¬≥-close to `f b` along `ùìù a`:
  `(f a, F i a) ‚àà v` from `i ‚àà I‚ÇÅ`,
  `(F i a, F i b) ‚àà v` from the `i ‚àà I‚ÇÇ` we just used, and then
  `(F i b, f b) ‚àà v` from `i ‚àà I‚ÇÅ` again and the symmetry we required of `v`.
  -/
  have : ‚àÄ·∂†b in ùìù a, (f a, f b) ‚àà v ‚óã v ‚óã v := this.mono fun b hb ‚Ü¶
    ‚ü®F i b, ‚ü®F i a, hI‚ÇÅ i hi‚ÇÅ a, hb‚ü©, v_symm.mk_mem_comm.mp <| hI‚ÇÅ i hi‚ÇÅ b‚ü©
  -- now, we use the inequality part (v¬≥ ‚äÜ s) to get `‚àÄ·∂†b in ùìù a, (f a, f b) ‚àà s`. QED :)
  this.mono fun _ h ‚Ü¶ hv3s h

namespace Dini
open Filter
variable {X Œπ} [TopologicalSpace X] [Preorder Œπ]

example {F: Œπ ‚Üí X ‚Üí ‚Ñù} (hF_mono: Monotone F) (hf_cont: Continuous f)
  (h_tendsto: ‚àÄx, Tendsto (F ¬∑ x) atTop (ùìù (f x))) (hF_cont: ‚àÄi, Continuous (F i)) :
  TendstoLocallyUniformly F f atTop := atTop.eq_or_neBot.elim
    (fun h ‚Ü¶ tendstoLocallyUniformly_iff_forall_tendsto.mpr fun _ ‚Ü¶ h ‚ñ∏ bot_prod ‚ñ∏ tendsto_bot)
  fun [_] ‚Ü¶ Metric.tendstoLocallyUniformly_iff.mpr fun Œµ Œµ_pos a ‚Ü¶
  have hF_le (i) : (F i) ‚â§ f := fun x ‚Ü¶ ge_of_tendsto (h_tendsto x) <|
    eventually_ge_atTop i |>.mono fun _ ‚Ü¶ (hF_mono ¬∑ x)
  let G i := f - (F i)
  have hG_eq {i x} : dist (f x) (F i x) = G i x := abs_of_nonneg <| sub_nonneg.mpr <| hF_le i x
  have hG_cont i : Continuous (G i) := hf_cont.sub <| hF_cont i
  let E i := (G i) ‚Åª¬π' .Iio Œµ
  have hE_open i : IsOpen (E i) := isOpen_Iio.preimage <| hG_cont i
  have : .univ ‚äÜ ‚ãÉi, E i := fun x _ ‚Ü¶
    let ‚ü®i, hi‚ü© := Metric.tendsto_nhds.mp (h_tendsto x) Œµ Œµ_pos |>.exists
    ‚ü®E i, ‚ü®i, rfl‚ü©, hi.trans_eq' <| dist_comm .. |>.trans hG_eq |>.symm‚ü©
  have hE_mono : Monotone E :=
    have hG_anti : Antitone G := hF_mono.neg.const_add f
    have : Antitone (Set.preimage ¬∑ (.Iio Œµ)) := fun _ _ ‚Ü¶ (¬∑ ¬∑ |>.trans_lt)
    this.comp hG_anti
  -- have hE_dir : Directed (¬∑ ‚äÜ ¬∑) E := hE_mono.directed_le
  -- let ‚ü®i, hi‚ü© := CompactSpace.isCompact_univ.elim_directed_cover E hE_open this hE_dir
  -- eventually_ge_atTop i |>.mono fun j hj x ‚Ü¶ hG_eq.trans_lt <| hE_mono hj <| hi trivial
  let ‚ü®_S, ‚ü®i, (hi: E i = _S)‚ü©, hS‚ü© := this <| Set.mem_univ a
  have hEi : E i ‚àà ùìù a := hE_open i |>.mem_nhds <| hi.symm.subset hS
  ‚ü®E i, hEi, eventually_ge_atTop i |>.mono fun _j hj _x hx ‚Ü¶ hG_eq.trans_lt <| hE_mono hj hx‚ü©

variable {Y} [NormedAddCommGroup Y] [Lattice Y] [HasSolidNorm Y] [IsOrderedAddMonoid Y]

theorem dini_local {F: Œπ ‚Üí X ‚Üí Y} (hF_mono: Monotone F) (hf_cont: Continuous f)
  (h_tendsto: ‚àÄx, Tendsto (F ¬∑ x) atTop (ùìù (f x))) (hF_cont: ‚àÄi, Continuous (F i)) :
  TendstoLocallyUniformly F f atTop := atTop.eq_or_neBot.elim
    (fun h ‚Ü¶ tendstoLocallyUniformly_iff_forall_tendsto.mpr fun _ ‚Ü¶ h ‚ñ∏ bot_prod ‚ñ∏ tendsto_bot)
  fun [_] ‚Ü¶ Metric.tendstoLocallyUniformly_iff.mpr fun Œµ Œµ_pos a ‚Ü¶
  have hF_le (i) : (F i) ‚â§ f := fun x ‚Ü¶
    -- ge_of_tendsto (h_tendsto x) <|
    -- eventually_ge_atTop i |>.mono fun _ ‚Ü¶ (hF_mono ¬∑ x)
    sorry
  let G i x := ‚Äñ(f - (F i)) x‚Äñ
  have hG_eq {i x} : dist (f x) (F i x) = G i x := dist_eq_norm ..
  have hG_cont i : Continuous (G i) := continuous_norm.comp <| hf_cont.sub <| hF_cont i
  let E i := (G i) ‚Åª¬π' .Iio Œµ
  have hE_open i : IsOpen (E i) := isOpen_Iio.preimage <| hG_cont i
  have : .univ ‚äÜ ‚ãÉi, E i := fun x _ ‚Ü¶
    let ‚ü®i, hi‚ü© := Metric.tendsto_nhds.mp (h_tendsto x) Œµ Œµ_pos |>.exists
    ‚ü®E i, ‚ü®i, rfl‚ü©, hi.trans_eq' <| dist_comm .. |>.trans hG_eq |>.symm‚ü©
  have hE_mono : Monotone E :=
    have {i} : G i = (‚Äñ¬∑‚Äñ) ‚àò (f - (F i)) := rfl
    have : G = ((‚Äñ¬∑‚Äñ) ‚àò ¬∑) ‚àò (f - F ¬∑) := rfl
    have unga : Monotone ((‚Äñ¬∑‚Äñ) ‚àò ¬∑) := fun f g hfg x ‚Ü¶
      by
      dsimp

      sorry
    have : Antitone (f - F ¬∑) := (funext fun i ‚Ü¶ sub_eq_add_neg f (F i)) ‚ñ∏ hF_mono.neg.const_add f
    have hG_anti : Antitone G := Monotone.comp_antitone unga this
    have : Antitone (Set.preimage ¬∑ (.Iio Œµ)) := fun _ _ ‚Ü¶ (¬∑ ¬∑ |>.trans_lt)
    this.comp hG_anti
  -- have hE_dir : Directed (¬∑ ‚äÜ ¬∑) E := hE_mono.directed_le
  -- let ‚ü®i, hi‚ü© := CompactSpace.isCompact_univ.elim_directed_cover E hE_open this hE_dir
  -- eventually_ge_atTop i |>.mono fun j hj x ‚Ü¶ hG_eq.trans_lt <| hE_mono hj <| hi trivial
  let ‚ü®_S, ‚ü®i, (hi: E i = _S)‚ü©, hS‚ü© := this <| Set.mem_univ a
  have hEi : E i ‚àà ùìù a := hE_open i |>.mem_nhds <| hi.symm.subset hS
  ‚ü®E i, hEi, eventually_ge_atTop i |>.mono fun _j hj _x hx ‚Ü¶ hG_eq.trans_lt <| hE_mono hj hx‚ü©

end Dini
